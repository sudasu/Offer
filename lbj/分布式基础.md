#分布式基础
##分布式一致性问题
###概述
分布式一致性问题就是指，一个或多个进程提议了一个值后使系统所有进程对这个值达成一致意见。
![分布式一致问题](https://pic3.zhimg.com/80/v2-fec5a5ee8ee501ffcec3c0a48ce60e12_720w.jpg)
这样协定问题在分布式系统中的常见场景:

* 领导者选举：进程对leader达成一致
* 互斥：进程对进入临界区的进程达成一致
* 原子广播：进程对消息传递顺序达成一致(啥意思？)

如果在一个不出故障的系统中，是很容易解决分布式一致性问题的。但实际分布式系统一般是基于消息传递的异步分布式系统，进程可能会响应缓慢，被杀死或者重启，导致消息**延迟，丢失，重复，乱序**等。在上述发生异常的分布式系统中就形成一致性决议，保证无论发生任何异常都不会破坏协议的一致性，这些正是一致性算法要解决的问题。
###典型应用场景
分布式存储系统中经常使用多副本的方式实现容错，每一份数据都保留多个副本，这样保证部分数据的失效不会导致数据不可用。但这样每次更新操作都需要更新数据的所有副本，使得多副本的数据保持一致，但如果是在一个会出现各种故障的异步分布式系统中将如何保证同一数据的多副本一致性呢？  
同步复制为最高保护模式 (Maximum Protection)，异步复制为最高性能模式 (Maximum Performance)，还有一种最高可用性模式 (Maximum Availability) 介于两者之间，在正常情况下，它和最高保护模式一样，但一旦同步出现故障，立即切换成最高性能模式。传统的主从同步无法同时保持数据的一致性和可用性。  
而Paxos、Raft等分布式一致性算法则可在一致性和可用性之间取得很好的平衡。
###多副本状态机
多副本状态机是指多台机器具有完全相同的状态，并且运行完全相同的确定性状态机。通过这样的状态机，可以解决很多分布式系统中的容错问题，因为多副本状态机通常可以容忍半数节点故障。  
多副本状态机的每个副本上都保存有完全相同的操作日志，保证状态机副本按照相同的顺序执行相同的操作。这样由于状态机是确定性的，则会得到相同的状态。而保证复制到各个服务器上的日志的一致性正是分布式一致性算法的工作。
##Paxos算法
重要概念：提案，准备请求，接受请求，角色。角色关系如下：
![角色关系](https://img-blog.csdnimg.cn/20200524134207413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbjgxOTc0NzI2Mw==,size_16,color_FFFFFF,t_70)
paxos伪代码如下:</br>  
![paxos伪代码](https://pic2.zhimg.com/80/v2-8d4eaf5fdeb145e8bdf5e3bb1af408c9_720w.jpg)

</br>paxos中文逻辑
![paxos中文逻辑](https://upload-images.jianshu.io/upload_images/1752522-44c5a422f917bfc5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

[优秀例子](https://blog.csdn.net/cnh294141800/article/details/53768464)

##Nagle算法
压缩数据传输的次数，使得发送方只有一个未确认的小分组(小分组指报文长度小于MSS(Max Segment Size，用于tcp协议，主要担心数据报被分段一般512字节，MTU为应用数据链路层，一般为1500字节))，该分组ack为收到前不能发送其他小分组。主要tcp报文较大，如果小报文过多，将会浪费网络资源，这种时候还是选择udp自己控制吧。
# netty
ByteBuf：拥有读写两个index，且附带许多方便api去清除，标记，复制等操作。
ChannelFuture：netty大部分操作都是异步的，write和writeAndFlush等方法返回future，而由future添加的监听器实现的close将会响应调用而不立即执行（当然如果直接Channel的close方法会导致未写完就断开连接）。

# 负载均衡
