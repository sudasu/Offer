# 常见问题

## URL编码问题

url采用ASCII码而不是Unicaode，所以url只包含英文字母，数字，某些特殊字符和保留字符。但如果URL中有汉字就必须进行编码处理，但标准的国际组织并没有规定具体的编码方法，而是交给浏览器自己决定。一般的chrome，firefox都是采用百分号编码，又%加上两个16进制的字符组成一个字节，所以一个字节被表现为%xx。一般为了解决这个问题，推荐使用encodeURI()函数进行转码,encodeURIComponent会对"/,:"组成部分编码。"application/x-www-form-urlencoded"数据类型直接就能转化？

## CNAME

cname被称为别名记录，即将该域名映射至别的域名上。一般CNAME用作CDN加速，即使用自己的域名通过CNAME指向CDN提供商提供的域名，当用户访问时本地DNS会使用CNAME指向的域名，而DNS调度系统会智能分析此域名使该域名指向一个离用户地理位置最近(或别的策略)CDN提供商的服务器IP。(linux使用dig指令管理)

## rtmp,httpflv,hls

![协议对比](https://upload-images.jianshu.io/upload_images/238151-6b9f5a7f9b6bd12d.png?imageMogr2/auto-orient/strip|imageView2/2/w/865/format/webp.jpg)

## 端口

1.端口就是个数字，其实就是个逻辑概念并不存在端口阻塞空闲影响带宽之类的情况。2.套接字由协议类型，源ip，目的ip，源端口，目的端口组成，所以监听时是使用的80端口，建立连接后使用的也是80端口。

## [全连接/半连接队列](https://www.cnblogs.com/XDU-Lakers/p/13179845.html)

## [RFC](https://datatracker.ietf.org/doc/search?name=html&rfcs=on&activedrafts=on&olddrafts=on)

## reuseport reuseaddr

reuseaddr主要还是为了快速复用处于TIME_WAIT状态(发送缓冲区的数据还未发送完毕)的端口，当然一个端口绑定多个处于TIME_WAIT状态和一个正常运行的socket有可能会造成其他风险。而reuseport则是对同时监听同端口的socket进行内核级别的负载均衡，程序员不用考虑其流量分发时的效率问题。

## 自适应hash

innodb存储引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问（一般三次），便会对该二级索引建立哈希索引提升速度。但可能意义不是很大，一般用仅作等值匹配，占用innodb_buffer_pool空间。

## 索引失效的特殊情况

很多时候mysql有自己的优化策略，而不按照设计者的目的来走索引。如inner join时mysql会根据自己的判断选择哪张表作为驱动表，此时可以使用STRAIGHT_JOIN或者左右连接的方式来指定连接顺序。

## 建表注意事项

1.热点数据和普通数据分开建表，有助于mysql的bufferpool产生作用（缓冲池就那么大，冷数据和热数据放在一张表，冷数据会占用额外的空间）。2.索引。3.分库分表。

## False Sharing

CPU按照64b块大小来缓存数据的，也就是Cache Line。而如果不同核的多个volatile变量存在同一Cache Line上，由于MESI缓存一致性协议，其中一个核的变量更新了会通知其他核更新数据(cpu内部沟通交换cache，因为都有数据所以不走内存了)，会造成无效的cpu带宽浪费。解决方案可以用数据将cache line对齐，以空间换时间和带宽，java可以使用@Contended注解标识(java使用128bytes，两倍cache line大小以调整相邻扇区预取导致的伪共享，不懂啥意思)，该注解的value可以赋相同的值用来进行分组增加空间利用效率。

## IO合并

所谓的IO合并就是如果多个进程请求的是连续物理地址上的数据，则将这些IO合并成单个IO一并处理，提升IO效率。

## [MMAP](https://www.cnblogs.com/huxiao-tee/p/4660352.html)

mmap是一种内存映射文件的方法，即将一个文件或者其他对象映射至进程的地址空寂，实现物理地址和虚拟地址的对应关系。进程可以通过采用指针操作这段内存，系统会自动将脏页面写回到对应磁盘上，而不用调用read,write等系统调用函数。其次，，，，从而实现了不同进程间的文件共享。mmap()必须以PAGE_SIZE为单位进行映射，内存也只能以页的单位进行映射。

## `fsync()`系统调用相关

### 磁盘同步函数

`sync()`，`fsync()`， `fdatasync()`都是linux提供的磁盘同步函数，分别有以下特点。  

* `sync()`函数是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束，通常被称为update的系统守护进程周期性(一般每隔30秒)调用。这就保证了定期冲洗内核的块缓冲区。命令sync(1)也调用sync函数。  
* `fsync()`函数只对由文件描述符fd指定的单一文件起作用，并且pending write到磁盘操作结束，然后返回。fsync可用于数据库这样的应用程序，需要确保修改过的块立即写到磁盘上。  
* `fdatasync()`类似于`fsync()`，但只影响文件的数据部分，而fsync除数据外还会同步更新文件的属性。

### 为什么需要磁盘同步函数

传统的UNIX实现在内核中设有__缓冲区高速缓存__或__页面高速缓存__，大多数磁盘I/O都通过缓冲进行。当将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中，如果该缓冲区尚未写满，则并不将其排入<font color="#ff0000">__输出队列__</font>，而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时，再将该缓冲排入（调用`flush()`命令）输出队列，然后待其到达队首时，才进行实际的I/O操作。这种输出方式被称为__延迟写（delayed write）__。

延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度，使得欲写到文件中的数据在一段时间内并没有写到磁盘上。当系统发生故障时，这种延迟可能造成文件更新内容的丢失。为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX系统提供了sync、fsync和fdatasync三个函数。

## `write()`和`fsync()`区别
