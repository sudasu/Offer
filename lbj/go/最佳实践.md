# [最佳实践](https://github.com/golang/go/wiki/CodeReviewComments#interfaces)

## volatile关键字替代

volatile关键字的本质是共享内存可见，但go的宗旨是通信代替共享内存，所以没有volatile关键字。go锁的代价比较低，可以使用锁，也可以使用chan来实现，但使用cas代价是最低的，如下。

```go
// 测试并行任务创建时，是否只能一个任务创建成功
func TestSetHashNx(t *testing.T) {
	ctx := context.Background()
	var er int64 = 0
	var nc int64 = 0
	var cr int64 = 0
	var wg sync.WaitGroup
	obj := model.IdcBwStatCacheData{
		State:     1,
		StartTime: "2022-07-08 13:22:55",
		EndTime:   "2022-07-08 14:22:55",
		Data:      "dasdasdas",
		Version:   "v0.0.1",
	}
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			ok, err := d.SetHashValueNX(ctx, "dasdasdsadas", obj, "Version", 60)
			if err != nil {
				atomic.AddInt64(&er, 1)
				return
			}
			if ok {
				atomic.AddInt64(&cr, 1)
				return
			} else {
				atomic.AddInt64(&nc, 1)
				return
			}
		}()
	}
	wg.Wait()
	log.Info("任务错误执行个数：%v，任务成功执行个数：%v，任务重复失败执行个数：%v", atomic.LoadInt64(&er), atomic.LoadInt64(&cr), atomic.LoadInt64(&nc))
}
```

## [切片任意位置插入数据](https://haicoder.net/golang/golang-slice-add.html)