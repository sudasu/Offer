# 二叉树

```go
type TreeNode struct {
	Val   int
	Left  *Node
	Right *Node
}
```
## 递归遍历

```go
// 递归法完成前、中、后序遍历
func dfs(n *TreeNode){
    if n == nil {
        return
    }
    // 前序遍历 arr = append(arr,n.Val)
    dfs(n.Left)
    // 中序遍历 arr = append(arr,n.Val)
    dfs(n.Right)
    // 后序遍历 arr = append(arr,n.Val)
}

func inorderTraversal(root *TreeNode) []int {
    var rst []int
    var dfs func(n *TreeNode)
    dfs = func(n *TreeNode){
        if n == nil {
            return
        }
        dfs(n.Left)
        rst = append(rst,n.Val)
        dfs(n.Right)
    }
    dfs(root)
    return rst
}
```

特点：
1. 中序遍历的结果可以检查是否满足二叉搜索树
2. 后序遍历，如果采用非递归的方式，可以检查根节点到其值的路径

## 非递归遍历遍历

```go

// 前序遍历
func preordertraversal(n *Node){

}
// 中序遍历
func inorderTraversal(root *TreeNode) []int {
	var rst []int
	var stack []*TreeNode
	if root == nil {
		return rst
	}
	cur := root
	for len(stack) != 0 || cur != nil { // 中序和后序的通用模板
		for cur != nil {    // 左到底，然后输出
			stack = append(stack, cur)
			cur = cur.Left
		}
		cur = stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		rst = append(rst, cur.Val)
		cur = cur.Right
	}
	return rst
}
// 后序遍历
func postorderTraversal(root *TreeNode) []int {
    var rst []int
    if root == nil {
        return rst
    }
    cur := root
    var pre *TreeNode
    var stack []*TreeNode
    for cur != nil || len(stack) != 0{ // 中序和后序的通用模板
        for cur != nil{
            stack = append(stack,cur)
            cur = cur.Left
        }
        cur = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        if cur.Right == nil || cur.Right == pre{ // 标记是否上次有访问
            rst = append(rst,cur.Val)
            pre = cur
            cur = nil
        }else{
            stack = append(stack,cur) // 继续放回stack，因为还没轮到它输出
            cur = cur.Right
        }
    }
    return rst
}
// 层次遍历
// 复杂层序遍历，需要使用二维数组输出

func levelOrder(root *TreeNode) [][]int {
    var stack []*TreeNode
    var rst [][]int
    if root == nil{
        return rst
    }
    stack = append(stack,root)
    for len(stack) != 0{
        var r []int
        var stack2 []*TreeNode
        for len(stack) != 0{
            cur := stack[0] // 需要按顺序输出，此时需要用队列而不是栈
            stack = stack[1:len(stack)]
            r = append(r,cur.Val)
            if cur.Left != nil{
                stack2 = append(stack2,cur.Left)
            }
            if cur.Right != nil{
                stack2 = append(stack2,cur.Right)
            }
        }
        stack = stack2
        rst = append(rst,r)
    }
    return rst
}

```