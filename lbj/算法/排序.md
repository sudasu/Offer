# 排序

## 排序算法

快速：平均时间复杂度 O(nlogn) ,最坏时间复杂度是O(n2)，空间复杂度是O(logn)(一般本地排序空间复杂度都是O(1),但快排存在递归栈,分支算法的典型使用)。
冒泡：本地排序，平均时间复杂度O(n2)，空间复杂度O(1)，改进算法受初始状态影响,时间复杂度为O(n)
选择：本地排序，平均时间复杂度O(n2)，空间复杂度O(1)，不受数组初始状态影响，由于是本地排序，第一个遇见的值会被挪到后面去，所以不稳定。
插入：本地排序，平均时间复杂度O(n2)，空间复杂度O(1)，受数组初始状态影响，一开始就是有序的插入排序的复杂度为O(n)。
希尔：本地排序，平均时间复杂度O(nlogn)，空间复杂度O(1)，属于插入排序的变种，受数组初始状态影响,如果一开始就是有序的，则时间复杂度为O(logn)
归并：非本地排序，平均时间复杂度O(nlogn)，空间复杂度O(n)，两个有序数组合并排序，受数组初始状态影响,如果一开始就是有序的，会快一些每次比较的时间复杂度为O(n)，在改进后的最优情况还是nlogn(n/2+n/4+n/8+...+1),原来是nlogn(n/2*logn)。
堆排：本地排序，平均时间复杂度O(n2)，空间复杂度O(1)，不受数组初始状态影响。每次调整输出时间复杂度是O(logn),初始化时间复杂度是O(n)
基数排序，

稳定性：一堆希尔快选，不稳定

### 快速排序实现

```golang
func binary(array []int, s, e int) []int {
	if s >= e {
		return array
	}
	pos := simpleSort(array, s, e)
	binary(array, s, pos-1)
	binary(array, pos+1, e)
	return array
}

func simpleSort(array []int, l, r int) int {
	flag := array[l]
	swap := func(i, j int) {
		temp := array[i]
		array[i] = array[j]
		array[j] = temp
	}
	for l < r { // 之所以是<,就是为了在边界条件swap时，保证元素值不变
		for l < r && flag <= array[r] {
			r--
		}
		swap(l, r)
		for l < r && flag >= array[l] {
			l++
		}
		swap(l, r)
	}
	return l
}
```