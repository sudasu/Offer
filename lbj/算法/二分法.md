# 

## 二分法

对于快排，二分法的使用是两边同时调用单值排序，返回结果切割然后二分递归调用。一般的二分，则是简单的单边判断然后排除，常见case如下:

```go
// 注意细节如下：1.二分逼近最终都会以+-1的方式逼近极限，乃至超过极限。2.<=可以保证准确到达边界，超过边界就不比较了
// +1,-1不能省略，省略可能导致无法出循环
// <=的比较方案，一定回导致r = l - 1
// 如果没有匹配方案，从中间出来的话，需要注意判断出来的值是否是所想要的，如果是不想要的可以-+1以满足条件
func binary(nums []int , target int) int {
    l := 0
    r := len(nums) - 1
    if len(nums) == 0 {
        return -1
    }
    for l <= r {
        m := (r+l)/2
        if nums[m] == target{
            return m
        }
        if nums[m] < target{
            l = m + 1
        }else{
            r = m - 1
        }
    }
    return -1
}

// 找到上下边界
// 其中无论什么情况r最终都会停留在target pos - 1 的位置，而l则会停留在正确位置
// 如果不存在该值，则会r < target pos,l > target pos,该情况对于上边界和下边界均适用
// 所以如果不存在该值，返回的上边界l将会大于下边界r
func lowBound(nums []int , target int) int {
    l := 0
    r := len(nums) - 1
    if len(nums) == 0 {
        return -1
    }
    for l <= r {
        m := (r+l)/2
        if nums[m] < target{
            l = m + 1
        }else{
            r = m - 1
        }
    }
    return l
}

func highBound(nums []int , target int) int {
    l := 0
    r := len(nums) - 1
    if len(nums) == 0 {
        return -1
    }
    for l <= r {
        m := (r+l)/2
        if nums[m] <= target{
            l = m + 1
        }else{
            r = m - 1
        }
    }
    return r
}
```