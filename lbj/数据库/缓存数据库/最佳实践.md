# 最佳实践

## 一般策略

1. redis作为临时缓存，不存入持久型数据库之中。
2. 缓存实时更新，定期存入mysql。
3. mysql实时更新，定期更新redis。
4. 读redis,redis不存在读mysql并存入redis。写mysql,写成功后删除redis，此处需要保证一致性。
5. 直接单维护mysql

## 高并发抢购减一

1. 根据剩余数量的量级不同，进行不同的限流数量。
2. 根据剩余数量的量级不同，使用不同的缓存策略。如数量非常多，可以先使用缓存策略2，然后慢慢根据限流策略提升mysql的写的频率，最后采用策略5。

## 热度排序

1. 由于目前的热度排序对一致性要求没那么大，一般采用策略2，把控好写入频率即可。（关联删除条件注意一下，有可能是mysql的及联删除导致redis没有察觉）
2. 如果需要持久性，可以采用策略3，定期刷redis数据即可。
3. 如果热度排序还对应访问资源，相关的变更一定要实时交互，而不能采用策略3。

## 流量数据缓存报表

1. 查询代价不怎么昂贵，且qps低，所以采用策略5
2. 查询代价非常昂贵，所以应该尽量降低动用mysql的次数，适宜采用策略1和4。
3. 考虑到数据变更导致的查询结果出错的情况，由于很难排查到查询结果与数据变更的影响关系，且数据变更较少。所以不采用策略4，对策略1添加补偿逻辑。补偿逻辑如下：1.重启后删除所有缓存。2.缓存持续时间尽量的长。3.可以增加后台维护接口，更新缓存数据。