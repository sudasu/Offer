# redis

## AOF和RDB

RBD更新策略:900 1 / 60 10000(时间/次数)更新策略
AOF更新策略:每次修改触发/定时触发/永远不修改 

## 缓存穿透/缓存击穿/缓存雪崩的应对

缓存穿透：
缓存和数据库中都没有的数据，可用户还是源源不断的发起请求，导致每次请求都会到数据库，从而压垮数据库。

对于缓存穿透，我们可以将查询的数据条件都哈希到一个足够大的布隆过滤器中，用户发送的请求会先被布隆过滤器拦截，一定不存在的数据就直接拦截返回了，从而避免下一步对数据库的压力。

缓存击穿：
Redis中一个热点key在失效的同时，大量的请求过来，从而会全部到达数据库，压垮数据库。

1.设置热点数据永不过期 2.检测热点key，并定时更新 3.使用信号量、锁、或者队列等限制并发的方法。

缓存雪崩：
Redis中缓存的数据大面积同时失效，或者Redis宕机，从而会导致大量请求直接到数据库，压垮数据库

1.设置有效期均匀分布，避免缓存设置相近的有效期，我们可以在设置有效期时增加随机值，或者统一规划有效期，使得过期时间均匀分布。
2.数据预热,对于即将来临的大量请求，我们可以提前走一遍系统，将数据提前缓存在Redis中，并设置不同的过期时间。

## bigkey引发的问题

## 常用类型及底层结构

redis数据类型
1）String(字符串)：value最大能存储512M
2）List(列表)：lpush，左边添加元素；lrange key 0,10，查看key列表0到10的元素
3）Set(集合)：元素唯一；sadd，添加元素；smembers key，查看key集合
4）Sort Set(有序集合)：元素唯一，每个元素都会关联一个double类型的分数，通过分数来为集合中的元素从小到大进行排序；zadd key score value，往key集合中添加元素；
5）hash(哈希)：value为键值对；HMSET key value，设置值；HGET 大key 小key，获取值​

## 过期策略

redis的过期策略就是：定期删除 + 惰性删除
redis是每隔100ms就随机抽取一些key来检查和删除的，但如果定期删除漏掉了很多过期的key，然后你也没及时去查，也就没走惰性删除。此时依旧有可能大量过期的key堆积在内存里，导致内存耗尽。

​这个时候就需要内存淘汰机制了
内存淘汰机制
​redis内存淘汰机制有以下几个：
noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。这个一般很少用。
allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key，这个是最常用的。
allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除