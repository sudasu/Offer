# jvm

## 运行时数据区域

### 程序计数器

jvm支持多线程并发执行，每个线程都拥有自己的程序计数器，程序计数器记录着当前jvm指令执行的地址。如果此时执行的方法是本地方法，则程序计数器的值为null。

### java虚拟机栈

java虚拟机栈为每个线程私有，由一个个栈帧组成。栈帧的内存分布并不需要连续的，由堆空间进行分配，虚拟机栈只负责弹出和压入。虚拟机栈空间的大小可以选择固定大小或动态扩充压缩。当jvm栈是固定大小的，则每个jvm栈的大小在创建时可被独立决定。jvm需要提供给程序员或使用者动态控制jvm stack大小的方法，且包含可控制的最大和最小增删尺寸。如果一个线程请求的栈深度超过允许将会抛出StackOverFlowError，如果jvm stack大小是可动态扩充的，则如果扩充超过可使用内存大小会抛出OutOfMemoryError。

### 堆

堆内存为所有的jvm线程共享，用于存放对象实例，如果不能内存空间不能满足堆内存的扩充将抛出OutOfMemoryError。(虚拟机规范说对象实例，数组都应该在堆上分配。但是现在逃逸分析技术的日渐强大，即时编译技术的进步，或许可以直接用栈上分布等手段提高效率。)

### 方法区

方法区类比传统语言的被编译后代码存储区间或者说操作系统进程的文本段。它存储每个类的运行时常量池，字段和方法数据，方法和构造函数的代码，以及类，实例，接口初始化时的特殊方法`实例<init>,类<cinit>`。虽然方法区从逻辑上属于堆，但可以既不进行垃圾回收也不进行收缩扩充空间，jvm规范也并不指定方法区的位置和已被编译后的代码的管理策略。

### [运行时常量池](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4)

运行时常量池从属于方法区，是每个类，接口的constant_pool表在运行时的表现形式，它包含了从编译期就已知的字面量到在必须在运行时才被解析的方法，字段引用。运行时常量池服务于方法，类似于传统编程语言里的符号引用表，但是包含更广泛的数据。jvm的指令并不依赖class,interface,instances等在运行时的布局，而是引用constant_pool表中的符号信息。constant_pool表中的每一个数据项都具有如下通用格式，其中tag为一字节大小表示cp_info的类型。。

```
cp_info{
    ul tag;
    ul info; //一般为索引或者具体字符信息
}

tag type:1.Utf8(用来表示二进制类或接口名),3.Integer,4.Float,5.Long,6.Double,7.class,8.String,9.Fieldref,10.Methodref,11.InterfaceMethodref,12.NameAndType,15.MethodHandle,16.MethodType,18.InvokeDynamic。
```
