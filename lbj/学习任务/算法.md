# 算法

## 二分法

对于快排，二分法的使用是两边同时调用单值排序，返回结果切割然后二分递归调用。一般的二分，则是简单的单边判断然后排除，常见case如下:

```go
// 注意细节如下：1.二分逼近最终都会以+-1的方式逼近极限，乃至超过极限。2.<=可以保证准确到达边界，超过边界就不比较了
// +1,-1不能省略，省略可能导致无法出循环
// <=的比较方案，一定回导致r = l - 1
// 如果没有匹配方案，从中间出来的话，需要注意判断出来的值是否是所想要的，如果是不想要的可以-+1以满足条件
func binary(nums []int , target int) int {
    l := 0
    r := len(nums) - 1
    if len(nums) == 0 {
        return -1
    }
    for l <= r {
        m := (r+l)/2
        if nums[m] == target{
            return m
        }
        if nums[m] < target{
            l = m + 1
        }else{
            r = m - 1
        }
    }
    return -1
}
```

## 排序算法

快速：平均时间复杂度 O(nlogn) ,最坏时间复杂度是O(n2)，空间复杂度是O(logn)(一般本地排序空间复杂度都是O(1),但快排存在递归栈,分支算法的典型使用)。
冒泡：本地排序，平均时间复杂度O(n2)，空间复杂度O(1)，改进算法受初始状态影响,时间复杂度为O(n)
选择：本地排序，平均时间复杂度O(n2)，空间复杂度O(1)，不受数组初始状态影响，由于是本地排序，第一个遇见的值会被挪到后面去，所以不稳定。
插入：本地排序，平均时间复杂度O(n2)，空间复杂度O(1)，受数组初始状态影响，一开始就是有序的插入排序的复杂度为O(n)。
希尔：本地排序，平均时间复杂度O(nlogn)，空间复杂度O(1)，属于插入排序的变种，受数组初始状态影响,如果一开始就是有序的，则时间复杂度为O(logn)
归并：非本地排序，平均时间复杂度O(nlogn)，空间复杂度O(n)，两个有序数组合并排序，受数组初始状态影响,如果一开始就是有序的，会快一些每次比较的时间复杂度为O(n)，在改进后的最优情况还是nlogn(n/2+n/4+n/8+...+1),原来是nlogn(n/2*logn)。
堆排：本地排序，平均时间复杂度O(n2)，空间复杂度O(1)，不受数组初始状态影响。每次调整输出时间复杂度是O(logn),初始化时间复杂度是O(n)
基数排序，

稳定性：一堆希尔快选，不稳定

### 快速排序实现

```golang
func binary(array []int, s, e int) []int {
	if s >= e {
		return array
	}
	pos := simpleSort(array, s, e)
	binary(array, s, pos-1)
	binary(array, pos+1, e)
	return array
}

func simpleSort(array []int, l, r int) int {
	flag := array[l]
	swap := func(i, j int) {
		temp := array[i]
		array[i] = array[j]
		array[j] = temp
	}
	for l < r {
		for l < r && flag <= array[r] {
			r--
		}
		swap(l, r)
		for l < r && flag >= array[l] {
			l++
		}
		swap(l, r)
	}
	return l
}
```