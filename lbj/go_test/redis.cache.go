// Code generated by kratos tool redisgen. DO NOT EDIT.

/*
  Package go_test is a generated redis cache package.
  It is generated from:
  type _redis interface {
		// redis: -key=demoKey
		CacheDemos(c context.Context, keys []int64) (map[int64]*Demo, error)
		// redis: -key=demoKey -encode=json|gzip
		CacheDemo(c context.Context, key int64) (*Demo, error)
		// redis: -key=keyMid -encode=pb|gzip
		CacheDemo1(c context.Context, key int64, mid int64) (*Demo, error)
		// redis: -key=noneKey -encode=pb|gzip
		CacheNone(c context.Context) (*Demo, error)
		// redis: -key=demoKey
		CacheString(c context.Context, key int64) (string, error)

		// redis: -key=demoKey -expire=d.demoExpire -encode=json
		AddCacheDemos(c context.Context, values map[int64]*Demo) error
		// redis: -key=demo2Key -expire=d.demoExpire -encode=json
		AddCacheDemos2(c context.Context, values map[int64]*Demo, tp int64) error
		// 这里也支持自定义注释 会替换默认的注释
		// redis: -key=demoKey -expire=d.demoExpire -encode=json|gzip
		AddCacheDemo(c context.Context, key int64, value *Demo) error
		// redis: -key=keyMid -expire=d.demoExpire -encode=pb
		AddCacheDemo1(c context.Context, key int64, value *Demo, mid int64) error
		// redis: -key=noneKey -expire=d.demoExpire -encode=pb|gzip
		AddCacheNone(c context.Context, value *Demo) error
		// redis: -key=demoKey -expire=d.demoExpire
		AddCacheString(c context.Context, key int64, value string) error

		// redis: -key=demoKey
		DelCacheDemos(c context.Context, keys []int64) error
		// redis: -key=demoKey
		DelCacheDemo(c context.Context, key int64) error
		// redis: -key=keyMid
		DelCacheDemo1(c context.Context, key int64, mid int64) error
		// redis: -key=noneKey
		DelCacheNone(c context.Context) error
	}
*/

package go_test

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/json"
	"github.com/gogo/protobuf/proto"
	"io"

	"go-common/library/cache/redis"
	"go-common/library/log"
)

var _ _redis

// CacheDemos get data from redis
func (d *dao) CacheDemos(c context.Context, ids []int64) (res map[int64]*Demo, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	idxMap := make(map[int]string, l)
	args := redis.Args{}
	for idx, id := range ids {
		key := demoKey(id)
		idxMap[idx] = key
		keysMap[key] = id
		args = args.Add(key)
	}
	values, err := redis.ByteSlices(d.redis.Do(c, "MGET", args...))
	if err != nil {
		log.Errorc(c, "d.CacheDemos() error(%v)", err)
		return
	}
	for idx, temp := range values {
		if temp == nil {
			continue
		}
		var v *Demo
		v = &Demo{}
		err = json.Unmarshal(temp, v)
		if err != nil {
			log.Errorc(c, "d.CacheDemos() err: %+v", err)
			return
		}
		if res == nil {
			res = make(map[int64]*Demo, len(values))
		}
		key := idxMap[idx]
		res[keysMap[key]] = v
	}
	return
}

// CacheDemo get data from redis
func (d *dao) CacheDemo(c context.Context, id int64) (res *Demo, err error) {
	key := demoKey(id)
	reply, err1 := redis.Bytes(d.redis.Do(c, "GET", key))
	if err1 != nil {
		if err1 == redis.ErrNil {
			return
		}
		err = err1
		log.Errorc(c, "d.CacheDemo(get key: %v) err: %+v", key, err)
		return
	}
	res = &Demo{}
	gzipReader, err1 := gzip.NewReader(bytes.NewReader(reply))
	if err1 != nil {
		err = err1
		log.Errorc(c, "d.CacheDemo(get key: %v) err: %+v", key, err)
		return
	}
	defer gzipReader.Close()
	var buf bytes.Buffer
	io.Copy(&buf, gzipReader)
	err = json.Unmarshal(buf.Bytes(), res)
	if err != nil {
		log.Errorc(c, "d.CacheDemo(get key: %v) err: %+v", key, err)
		return
	}
	return
}

// CacheDemo1 get data from redis
func (d *dao) CacheDemo1(c context.Context, id int64, mid int64) (res *Demo, err error) {
	key := keyMid(id, mid)
	reply, err1 := redis.Bytes(d.redis.Do(c, "GET", key))
	if err1 != nil {
		if err1 == redis.ErrNil {
			return
		}
		err = err1
		log.Errorc(c, "d.CacheDemo1(get key: %v) err: %+v", key, err)
		return
	}
	res = &Demo{}
	gzipReader, err1 := gzip.NewReader(bytes.NewReader(reply))
	if err1 != nil {
		err = err1
		log.Errorc(c, "d.CacheDemo1(get key: %v) err: %+v", key, err)
		return
	}
	defer gzipReader.Close()
	var buf bytes.Buffer
	io.Copy(&buf, gzipReader)
	err = proto.Unmarshal(buf.Bytes(), res)
	if err != nil {
		log.Errorc(c, "d.CacheDemo1(get key: %v) err: %+v", key, err)
		return
	}
	return
}

// CacheNone get data from redis
func (d *dao) CacheNone(c context.Context) (res *Demo, err error) {
	key := noneKey()
	reply, err1 := redis.Bytes(d.redis.Do(c, "GET", key))
	if err1 != nil {
		if err1 == redis.ErrNil {
			return
		}
		err = err1
		log.Errorc(c, "d.CacheNone(get key: %v) err: %+v", key, err)
		return
	}
	res = &Demo{}
	gzipReader, err1 := gzip.NewReader(bytes.NewReader(reply))
	if err1 != nil {
		err = err1
		log.Errorc(c, "d.CacheNone(get key: %v) err: %+v", key, err)
		return
	}
	defer gzipReader.Close()
	var buf bytes.Buffer
	io.Copy(&buf, gzipReader)
	err = proto.Unmarshal(buf.Bytes(), res)
	if err != nil {
		log.Errorc(c, "d.CacheNone(get key: %v) err: %+v", key, err)
		return
	}
	return
}

// CacheString get data from redis
func (d *dao) CacheString(c context.Context, id int64) (res string, err error) {
	key := demoKey(id)
	var temp []byte
	temp, err = redis.Bytes(d.redis.Do(c, "GET", key))
	if err != nil {
		if err == redis.ErrNil {
			err = nil
			return
		}
		log.Errorc(c, "d.CacheString(get key: %v) err: %+v", key, err)
		return
	}
	res = string(temp)
	return
}

// AddCacheDemos Set data to redis
func (d *dao) AddCacheDemos(c context.Context, values map[int64]*Demo) (err error) {
	if len(values) == 0 {
		return
	}
	p := d.redis.Pipeline()
	for id, val := range values {
		key := demoKey(id)
		var bs []byte
		bs, err = json.Marshal(val)
		if err != nil {
			log.Errorc(c, "d.AddCacheDemos() err: %+v", err)
			return
		}
		expire := d.demoExpire
		p.Send("set", key, bs, "ex", expire)
	}
	if _, err = p.Exec(c); err != nil {
		log.Errorc(c, "d.AddCacheDemos() err: %v", err)
	}
	return
}

// AddCacheDemos2 Set data to redis
func (d *dao) AddCacheDemos2(c context.Context, values map[int64]*Demo, tp int64) (err error) {
	if len(values) == 0 {
		return
	}
	p := d.redis.Pipeline()
	for id, val := range values {
		key := demo2Key(id, tp)
		var bs []byte
		bs, err = json.Marshal(val)
		if err != nil {
			log.Errorc(c, "d.AddCacheDemos2() err: %+v", err)
			return
		}
		expire := d.demoExpire
		p.Send("set", key, bs, "ex", expire)
	}
	if _, err = p.Exec(c); err != nil {
		log.Errorc(c, "d.AddCacheDemos2() err: %v", err)
	}
	return
}

// AddCacheDemo 这里也支持自定义注释 会替换默认的注释
func (d *dao) AddCacheDemo(c context.Context, id int64, val *Demo) (err error) {
	if val == nil {
		return
	}
	key := demoKey(id)
	var bs []byte
	bs, err = json.Marshal(val)
	if err != nil {
		log.Errorc(c, "d.AddCacheDemo(get key: %v) err: %+v", key, err)
		return
	}
	var wriBuf bytes.Buffer
	gw := gzip.NewWriter(&wriBuf)
	_, err = gw.Write(bs)
	if err != nil {
		log.Errorc(c, "d.AddCacheDemo(get key: %v) err: %+v", key, err)
		return
	}
	gw.Close()
	bs = wriBuf.Bytes()
	expire := d.demoExpire
	if _, err = d.redis.Do(c, "set", key, bs, "EX", expire); err != nil {
		log.Errorc(c, "d.AddCacheDemo(get key: %v) err: %+v", key, err)
		return
	}
	return
}

// AddCacheDemo1 Set data to redis
func (d *dao) AddCacheDemo1(c context.Context, id int64, val *Demo, mid int64) (err error) {
	if val == nil {
		return
	}
	key := keyMid(id, mid)
	var bs []byte
	bs, err = proto.Marshal(val)
	if err != nil {
		log.Errorc(c, "d.AddCacheDemo1(get key: %v) err: %+v", key, err)
		return
	}
	expire := d.demoExpire
	if _, err = d.redis.Do(c, "set", key, bs, "EX", expire); err != nil {
		log.Errorc(c, "d.AddCacheDemo1(get key: %v) err: %+v", key, err)
		return
	}
	return
}

// AddCacheNone Set data to redis
func (d *dao) AddCacheNone(c context.Context, val *Demo) (err error) {
	if val == nil {
		return
	}
	key := noneKey()
	var bs []byte
	bs, err = proto.Marshal(val)
	if err != nil {
		log.Errorc(c, "d.AddCacheNone(get key: %v) err: %+v", key, err)
		return
	}
	var wriBuf bytes.Buffer
	gw := gzip.NewWriter(&wriBuf)
	_, err = gw.Write(bs)
	if err != nil {
		log.Errorc(c, "d.AddCacheNone(get key: %v) err: %+v", key, err)
		return
	}
	gw.Close()
	bs = wriBuf.Bytes()
	expire := d.demoExpire
	if _, err = d.redis.Do(c, "set", key, bs, "EX", expire); err != nil {
		log.Errorc(c, "d.AddCacheNone(get key: %v) err: %+v", key, err)
		return
	}
	return
}

// AddCacheString Set data to redis
func (d *dao) AddCacheString(c context.Context, id int64, val string) (err error) {
	if len(val) == 0 {
		return
	}
	key := demoKey(id)
	var bs []byte
	bs = []byte(val)
	expire := d.demoExpire
	if _, err = d.redis.Do(c, "set", key, bs, "EX", expire); err != nil {
		log.Errorc(c, "d.AddCacheString(get key: %v) err: %+v", key, err)
		return
	}
	return
}

// DelCacheDemos delete data from redis
func (d *dao) DelCacheDemos(c context.Context, ids []int64) (err error) {
	if len(ids) == 0 {
		return
	}
	args := redis.Args{}
	for _, id := range ids {
		key := demoKey(id)
		args = args.Add(key)
	}
	if _, err = d.redis.Do(c, "del", args...); err != nil {
		log.Errorc(c, "d.DelCacheDemos() err: %+v", err)
		return
	}
	return
}

// DelCacheDemo delete data from redis
func (d *dao) DelCacheDemo(c context.Context, id int64) (err error) {
	key := demoKey(id)
	if _, err = d.redis.Do(c, "del", key); err != nil {
		if err == redis.ErrNil {
			err = nil
			return
		}
		log.Errorc(c, "d.DelCacheDemo(get key: %v) err: %+v", key, err)
		return
	}
	return
}

// DelCacheDemo1 delete data from redis
func (d *dao) DelCacheDemo1(c context.Context, id int64, mid int64) (err error) {
	key := keyMid(id, mid)
	if _, err = d.redis.Do(c, "del", key); err != nil {
		if err == redis.ErrNil {
			err = nil
			return
		}
		log.Errorc(c, "d.DelCacheDemo1(get key: %v) err: %+v", key, err)
		return
	}
	return
}

// DelCacheNone delete data from redis
func (d *dao) DelCacheNone(c context.Context) (err error) {
	key := noneKey()
	if _, err = d.redis.Do(c, "del", key); err != nil {
		if err == redis.ErrNil {
			err = nil
			return
		}
		log.Errorc(c, "d.DelCacheNone(get key: %v) err: %+v", key, err)
		return
	}
	return
}
