# [mysql指令](https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html)
## 配置文件
### mac配置
查看配置文件路径依赖：`mysqld --help --verbose | more`
一般配置依赖路径优先级：/etc/my.cnf <- /etc/mysql/my.cnf <- /usr/local/etc/my.cnf <- ~/.my.cnf
### 关闭ONLY\_FULL\_GROUP\_BY
1. 查看当前sql_mode:`select @@sql_mode`
2. 复制当前值且去掉 **ONLY_FULL_GROUP_BY**
3. `set sql_mode = '复制值'`;(这个似乎是改变当前库的，亲测有效。似乎新建的无效，新建的需要需要`set @@global.sql_mode`----每次重连失效[补充:mysql的变量分为local,session,global,配置文件四个级别。])

### mysql变量
全局变量：设置全局变量需要super权限(应该是指数据库的权限,root设置时似乎没遇见验证)。

```
mysql> SET GLOBAL sort_buffer_size=value;
mysql> SET @@global.sort_buffer_size=value;

mysql> SELECT @@global.sort_buffer_size;
mysql> SHOW GLOBAL VARIABLES like 'sort_buffer_size';
```
会话变量：等同与local变量，不需要权限验证

```
mysql> SET SESSION sort_buffer_size=value;
mysql> SET @@session.sort_buffer_size=value;
mysql> SET sort_buffer_size=value;

mysql> SELECT @@sort_buffer_size;
mysql> SELECT @@session.sort_buffer_size;
mysql> SHOW SESSION VARIABLES like 'sort_buffer_size';
```

临时变量：预处理，这样操作应该是把结果存在mysql中，而不必将它们存储在客户端的临时变量中(啥意思，客户端的临时变量，是指我们程序中存储的值。多次查询？)

```
mysql> SELECT @min_price:=MIN(price),@max_price:=MAX(price) FROM shop;
mysql> SELECT * FROM shop WHERE price=@min_price OR price=@max_price;
```
## 服务
### mac
(**注意第一次操作时会失效，可能是安装时启动没有录入pid，在mac服务里面关闭mysql服务后即可正常使用指令**)  
(**更新：使用mac启动服务就是没有pid**)
启动mysql:`sudo /usr/local/mysql/support-files/mysql.server start`  
停止mysql:`sudo /usr/local/mysql/support-files/mysql.server stop`  
重启mysql:`sudo /usr/local/mysql/support-files/mysql.server restart`
## sql
### in与or的区别
### 外键约束

### 批量插入时的冲突解决
批量插入：`insert into table_names() values(),...`和`insert into select`  

1. `replace into ...`:如有冲突先删除再插入，感觉性能会比较一般，删除和插入应该会影响b+树的分裂合并
2. `... on duplicate key update a=values(a),...`:如有冲突则更新，性能应该会比上好
3. `insert ignore into ...`:忽略插入，如有冲突或约束则跳过该插入继续执行。除了唯一约束的冲突，类似字段超出长度、类型不匹配等错误，前两种插入都会整体失败，但insert ignore into 则不会。它对于类型不匹配且无法转化的提供了默认值，超出了长度的单招最大长度进行截取。(由此可见很容易会漏掉错误而不被发现，所以用的少)

### left join注意举例
查询商店中商品价格最贵的供应商及相关信息。

1. left join以左边的表为基础进行连接，这样不满足条件的右边表便会以null形式展现出来。

```
SELECT s1.article, s1.dealer, s1.price
FROM shop s1
LEFT JOIN shop s2 ON s1.article = s2.article AND s1.price < s2.price
WHERE s2.article IS NULL
ORDER BY s1.article;
```

2. 对于`join`语句`select`部分如果不被group by区分，则必须使用聚合函数包裹起来，这也是如下采用子查询的原因？

```
SELECT s1.article, dealer, s1.price
FROM shop s1
JOIN (
  SELECT article, MAX(price) AS price
  FROM shop
  GROUP BY article) AS s2
  ON s1.article = s2.article AND s1.price = s2.price
ORDER BY article;
```

### 事务

```
START TRANSACTION or BEGIN start a new transaction.

COMMIT commits the current transaction, making its changes permanent.

ROLLBACK rolls back the current transaction, canceling its changes.

SET autocommit disables or enables the default autocommit mode for the current session.

READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ、SERIALIZABLE            //事务支持的隔离级别
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;   //设置事务的隔离级别，但是不允许此时有事务正在执行。
SET GLOBAL TRANSACTION SERIALIZABLE;            //注意，似乎只对下次事务一次有效(上面的语句一样的)
```

### 索引修改

索引相关指令：

1. 新增索引:`ALTER TABLE tb_name ADD [INDEX|UNIQUE|FULLTEXT index_name] | [PRIMARY KEY] (username(length)...)` //都需要指定长度。
2. 删除索引:`ALTER TABLE tb_name DROP [INDEX i | PRIMARY KEY]`
3. 修改索引依赖列为非空:`alter table tb_name modify column_name type(length) not null`
4. 查看索引`show index from tb_name [from db_name]`
5. 查看表的存储引擎`show create table tb_name`;

>
字段解析：  
Non\_unique:表示是否为唯一索引，是为0否为1。  
Null:表示是否含有Null，是为Yes否为NO。  
Key\_name:表示索引名。  
Column\_name,Seq\_in_index:分别表示列名，以及该列在索引中的位置如果为单列则改值为1，为组合索引则为索引的顺序。  
Collation:表示排序顺序显示"A"为升序，为NULL则表示无分裂。  
Cardinality:表示索引中唯一值数量的估算数量，基数越大，当进行联合时使用该索引的机会越大(???)。  
Sub\_part:表示列中被编入索引的字符的数量，如整列被编入则为NULL。  
Packed:指示关键字如何被压缩，若没被压缩则为NULL。  

### 数据导出

## 数据库相关

```
database db_name;  -- 创建数据库
show databases;           -- 显示所有的数据库
drop database db_name;    -- 删除数据库
use db_name;              -- 选择数据库
create table tb_name (字段名 varchar(20), 字段名 char(1));   -- 创建数据表模板,注意使用default时，字符串这边似乎有确定的要求'',必须使用单引号。
show tables;              -- 显示数据表
desc tb_name；            -- 显示表结构,等同show columns tb_name;
show all columns tb_name;         --  显示详细表信息，包含comment等
drop table tb_name；      -- 删除表
ALTER TABLE <表名> [修改选项]  -- 修改表
[修改选项]：
[ ADD COLUMN <列名> <类型>
| CHANGE COLUMN <旧列名> <新列名> <新列类型>
| ALTER COLUMN <列名> { SET DEFAULT <默认值> | DROP DEFAULT }
| MODIFY COLUMN <列名> <类型>
| DROP COLUMN <列名>
| RENAME TO <新表名>
| CHARACTER SET <字符集名>
| COLLATE <校对规则名> ]

alter table <表名> modify <列名> int auto_increment;	-- 设置为自增
```

### 基本语句
```
insert into tb_name (column1,column2,column3,...)[可省略]
 values (value1,value2,value3,...);  --插入
```

# [正则常用语法](http://c.biancheng.net/view/5124.html)
# vim指令

```
/|?					\\进入搜索模式，/向下搜索，?向上搜索,n顺应逻辑向下搜索，N反向逻辑搜索
G					\\跳转至尾部
gg					\\跳转至头部
```

替换：

```
表达式:[range]s/target/subsitute/[option]
range				//正常表示1,10，特殊字符.,$当前行到末尾，%表示整个文件。
option:
	g				//表示范围内全部替换
	c				//表示操作时需要确认
		y			//确认当前交互
		n			//取消当前交互
		a			//后续所有替换均不询问
		q			//不替换完当前提出
		l			//替换完当前退出
	i				//不区分大小写
```

# SSH

[其他](https://hujinyang.blog.csdn.net/article/details/116600163)