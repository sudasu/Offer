# [mysql指令](https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html)
## 配置文件
### mac配置
查看配置文件路径依赖：`mysqld --help --verbose | more`
一般配置依赖路径优先级：/etc/my.cnf <- /etc/mysql/my.cnf <- /usr/local/etc/my.cnf <- ~/.my.cnf
### 关闭ONLY\_FULL\_GROUP\_BY
1. 查看当前sql_mode:`select @@sql_mode`
2. 复制当前值且去掉 **ONLY_FULL_GROUP_BY**
3. `set sql_mode = '复制值'`;(这个似乎是改变当前库的，亲测有效。似乎新建的无效，新建的需要需要`set @@global.sql_mode`----每次重连失效[补充:mysql的变量分为local,session,global,配置文件四个级别。])

### mysql变量
全局变量：设置全局变量需要super权限(应该是指数据库的权限,root设置时似乎没遇见验证)。

```
mysql> SET GLOBAL sort_buffer_size=value;
mysql> SET @@global.sort_buffer_size=value;

mysql> SELECT @@global.sort_buffer_size;
mysql> SHOW GLOBAL VARIABLES like 'sort_buffer_size';
```
会话变量：等同与local变量，不需要权限验证

```
mysql> SET SESSION sort_buffer_size=value;
mysql> SET @@session.sort_buffer_size=value;
mysql> SET sort_buffer_size=value;

mysql> SELECT @@sort_buffer_size;
mysql> SELECT @@session.sort_buffer_size;
mysql> SHOW SESSION VARIABLES like 'sort_buffer_size';
```

临时变量：预处理，这样操作应该是把结果存在mysql中，而不必将它们存储在客户端的临时变量中(啥意思，客户端的临时变量，是指我们程序中存储的值。多次查询？)

```
mysql> SELECT @min_price:=MIN(price),@max_price:=MAX(price) FROM shop;
mysql> SELECT * FROM shop WHERE price=@min_price OR price=@max_price;
```
## 服务
### mac
(**注意第一次操作时会失效，可能是安装时启动没有录入pid，在mac服务里面关闭mysql服务后即可正常使用指令**)  
(**更新：使用mac启动服务就是没有pid**)
启动mysql:`sudo /usr/local/mysql/support-files/mysql.server start`  
停止mysql:`sudo /usr/local/mysql/support-files/mysql.server stop`  
重启mysql:`sudo /usr/local/mysql/support-files/mysql.server restart`
## sql
### in与or的区别
### 外键约束

### 批量插入时的冲突解决
批量插入：`insert into table_names values(),...`和`insert into select`  

1. `replace into ...`:如有冲突先删除再插入，感觉性能会比较一般，删除和插入应该会影响b+树的分裂合并
2. `... on duplicate key update a=values(a),...`:如有冲突则更新，性能应该会比上好
3. `insert ignore into ...`:忽略插入，如有冲突或约束则跳过该插入继续执行。除了唯一约束的冲突，类似字段超出长度、类型不匹配等错误，前两种插入都会整体失败，但insert ignore into 则不会。它对于类型不匹配且无法转化的提供了默认值，超出了长度的单招最大长度进行截取。(由此可见很容易会漏掉错误而不被发现，所以用的少)

### left join注意举例
查询商店中商品价格最贵的供应商及相关信息。

1. left join以左边的表为基础进行连接，这样不满足条件的右边表便会以null形式展现出来。

```
SELECT s1.article, s1.dealer, s1.price
FROM shop s1
LEFT JOIN shop s2 ON s1.article = s2.article AND s1.price < s2.price
WHERE s2.article IS NULL
ORDER BY s1.article;
```

2. 对于`join`语句`select`部分如果不被group by区分，则必须使用聚合函数包裹起来，这也是如下采用子查询的原因？

```
SELECT s1.article, dealer, s1.price
FROM shop s1
JOIN (
  SELECT article, MAX(price) AS price
  FROM shop
  GROUP BY article) AS s2
  ON s1.article = s2.article AND s1.price = s2.price
ORDER BY article;
```

### 事务

```
START TRANSACTION or BEGIN start a new transaction.

COMMIT commits the current transaction, making its changes permanent.

ROLLBACK rolls back the current transaction, canceling its changes.

SET autocommit disables or enables the default autocommit mode for the current session.

READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ、SERIALIZABLE            //事务支持的隔离级别
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;   //设置事务的隔离级别，但是不允许此时有事务正在执行。
SET GLOBAL TRANSACTION SERIALIZABLE;            //注意，似乎只对下次事务一次有效(上面的语句一样的)
```

### 索引修改

索引相关指令：

1. 新增索引:`ALTER TABLE tb_name ADD [INDEX|UNIQUE|FULLTEXT index_name] | [PRIMARY KEY] (username(length)...)` //都需要指定长度。
2. 删除索引:`ALTER TABLE tb_name DROP [INDEX i | PRIMARY KEY]`
3. 修改索引依赖列为非空:`alter table tb_name modify column_name type(length) not null`
4. 查看索引`show index from tb_name [from db_name]`
5. 查看表的存储引擎`show create table tb_name`;

>
字段解析：  
Non\_unique:表示是否为唯一索引，是为0否为1。  
Null:表示是否含有Null，是为Yes否为NO。  
Key\_name:表示索引名。  
Column\_name,Seq\_in_index:分别表示列名，以及该列在索引中的位置如果为单列则改值为1，为组合索引则为索引的顺序。  
Collation:表示排序顺序显示"A"为升序，为NULL则表示无分裂。  
Cardinality:表示索引中唯一值数量的估算数量，基数越大，当进行联合时使用该索引的机会越大(???)。  
Sub\_part:表示列中被编入索引的字符的数量，如整列被编入则为NULL。  
Packed:指示关键字如何被压缩，若没被压缩则为NULL。  

### 数据导出

## 数据库相关

```
database db_name;  -- 创建数据库
show databases;           -- 显示所有的数据库
drop database db_name;    -- 删除数据库
use db_name;              -- 选择数据库
create table tb_name (字段名 varchar(20), 字段名 char(1));   -- 创建数据表模板,注意使用default时，字符串这边似乎有确定的要求'',必须使用单引号。
show tables;              -- 显示数据表
desc tb_name；            -- 显示表结构,等同show columns tb_name;
show all columns tb_name;         --  显示详细表信息，包含comment等
drop table tb_name；      -- 删除表
ALTER TABLE <表名> [修改选项]  -- 修改表
[修改选项]：
[ ADD COLUMN <列名> <类型>
| CHANGE COLUMN <旧列名> <新列名> <新列类型>
| ALTER COLUMN <列名> { SET DEFAULT <默认值> | DROP DEFAULT }
| MODIFY COLUMN <列名> <类型>
| DROP COLUMN <列名>
| RENAME TO <新表名>
| CHARACTER SET <字符集名>
| COLLATE <校对规则名> ]

alter table <表名> modify <列名> int auto_increment;	-- 设置为自增
```

### 基本语句
```
insert into tb_name (column1,column2,column3,...)[可省略]
 values (value1,value2,value3,...);  --插入
```

# [正则常用语法](http://c.biancheng.net/view/5124.html)
# vim指令

```
/|?					\\进入搜索模式，/向下搜索，?向上搜索,n顺应逻辑向下搜索，N反向逻辑搜索
G					\\跳转至尾部
gg					\\跳转至头部
```

替换：

```
表达式:[range]s/target/subsitute/[option]
range				//正常表示1,10，特殊字符.,$当前行到末尾，%表示整个文件。
option:
	g				//表示范围内全部替换
	c				//表示操作时需要确认
		y			//确认当前交互
		n			//取消当前交互
		a			//后续所有替换均不询问
		q			//不替换完当前提出
		l			//替换完当前退出
	i				//不区分大小写
```

# git指令

## 常用基础

新增分支：`git branch branchname [版本号]`  //默认为当前分支创建，可根据log指定版本创建分支  
基于历史版本切换新增：`git checkout -b newbranch basebranch`       //基于分支或者版本号创建
删除分支：`git branch -d/-D [branchname]` -d不能删除未合并完成等中间状态分支，需要使用-D  
切换和文件忽略。  
删除远端分支:`git push origin --delete branchname`  
提交指令：git commit -a     			//-a表示提交修改和删除。新增还是需要add  
		   git commit --amend		//表示补充提交，在上次提交的基础上补充，而不会生成新的提交
新增指令：git add [-u|-A|.]   			//-u表示update。提交修改和删除，.是修改和新建，-A是所有删除，替换，修改，新增  

推送指令：git push origin branchname(不存在的话，自动创建远端分支)  //-f会强行覆盖掉冲突  
查看映射关系：git branch -vv  
建立远端映射：git push --set-upstream origin branchname  
忽略:对于未tracked文件，直接在.ignore文件添加即可。但已被tracker的文件，需要使用rm --cached移除索引再提交。但如果是需要被track，又不想让自己本地的更新被察觉，可以使用git update-index --assume-unchanged -- <file>指令，注意只能是file,而不能是filepath，如想取消可以使用no-assume-unchanged。事实证明不好使，总是有隐患的，比如reset hard后容易丢失。  
合并与变基:git rebase					//一般为了保证本地分支的整洁，在合并最新develop分支时都采用变基的方式而不
是merge

```
git rebase upstream [selectedbranch]		 //如果selected为空则将upstream分支基于当前分支rebase，如果不是为空则upsteam以selectedbranch为基础rebase且切换至selectedbranch。rebase是将别人的修改添加在你的分支的后面，方便你查看自己的分支log。
git rebase --onto abranch bbranch cbranch		//你甚至可以将依赖于b的c截断出来拼接到a上。
git rebase --continue|skip|abore			//在rebase过程中如果遇见了conflicts，有三种选择方式，要么解决冲突后continue。要么直接覆盖掉skip，要么取消rebase，切忌不要手贱commit否则使用abort退回。
git rebase -i head^2						//例子，交互式将当前修改压缩至上两个版本
```

stash指令：

```
git stash          				//执行存储 可 + save "save message"
git stash list 				//列出stash缓存列表
git stash show				//显示stash做了哪些改动，默认show第一个，如果需要看其他的需加上@{$num}
git stash pop				//恢复缓存的工作目录，会从list中去除
git stash apply				//应用第一个缓存，不会删除，如要使用其他的需加上 stash@{$num}
git stash drop stash@{$num}	//删除缓存
git stash clear				//删除所有缓存
```
回退指令:关于reset head^^后reset <head> --soft回原头节点的思考。混合型倒退head^^版本后，文件带回去了索引没带回去，所以status会显示很多修改。而软重置会原头节点，将文件带回去的同时将两个版本前的索引带回去了，status仍然会显示很多修改。这时千万不能按照索引来做修改，比如clean掉未track的，modify文件之类这样操作后的原head就变成head^^的状态了。如果不小心如此操作了，可以选择硬重置复原文件和索引，而正确操作是此时只需reset head，继续将当前状态的文件带回head但不带索引即将索引重置成head版本，即可。(最好瞎操作前，先commit或者stash，不然依靠版本控制重置文件，那存储之前的文件可就都没了)

```
git checkout [basebranch]-- filepath			//将工作区中的修改回退至暂存区的索引状态(add之前有效)，
												//相比较之下，reset filepath可根据各版本的情况去修改filepath下的索引，文件状态。更新一波，
												//hard不允许在filepath下reset，只能mixed，可能soft可以。

git checkout -b [localbranch] origin/[remotebranch] //拉取远端分支，且自动建立映射

git restore filepath        					//使用起来等同于checkout,可以加--staged参数将暂存区的索引退回
git revert HEAD^					//反向操作指定的版本以达到撤销，然后该操作可以当作commit提交。相比较reset的直线撤回，revert可以反做中间版本以用来撤回。其中revert默认是带编辑信息的提交，如需要不提交自己提交，使用 -n。如果遇见合并分支则无法撤回需要使用-m 指定分支进行撤回。撤回操作仍会导致conflicts，需要手动解决。
git reset [--soft|mixed|hard] [版本号]	//默认为混合型，且head版本 soft会回到暂存区已更新只差commit状态
mixed回回到暂存区未更新，工作区已更新的状态，还需add，hard则会直接丢失所有更改，可以无视现在的未提交直接重置。

快捷回退版本号
git reset						//混合型回退当前版本
git reset --hard HEAD~3 		//回退3个版本,0表示当前版本
git reset HEAD^^				//回退2个版本，表示切换到从当前开始的第三个版本
```

打扫指令:相比较reset，clean从当前目录清除未被track的文件，reset清除被track的文件。一般硬重置后都可能没有需要clean的(目前发现reset中途包含有merge,则需要clean)，混合重置可能会有没有add的，可以使用clean清理。

```
git clean 各后缀参数说明： 
-n 					//显示将要被删除的文件
-d	[path]			//如果没有给path，为了避免删除过多文件，并不会递归删除。使用-d递归删，如加了path则没啥影响
-f 	 				//一般默认配置都是不允许直接删除，必须使用-f来保证删除或者-i交互式删除
-i					//提供交互式问答，以保证删除的准确性
-x					//删除所有为track的文件，包括.gitignore里面的 
-X					//删除只包含在.gitignore里面的
```

rm指令

```
git rm <path> 指令说明:其中rm将会非递归的直接移除git目录的索引和文件
-f					//如index与文件状态不一致，需要使用-f强制覆盖移除
-r					//递归移除目录文件
--cached			//仅移除目标的index，即可用来ignore tracked文件
-n					//查看将要移除的文件，但不执行
```
log指令

```
git log 				//查看提交历史，以便确定回退到哪个版本
git log --oneline --graph --all	//查看分支图
git log -g			//会以标准格式输出reflog
git reflog 			//查看命令历史，以便回到hard reset后的版本
```

gc指令：工作时遇见了unable to update local ref的问题，使用gc解决了(有时间了再研究)
```
```

remote指令：维护远端信息

```
git remote -v                      //查看远端信息
git remote set-url origin [url]    //设置远端信息
git ls-remote --tag origin         //查看远端tag
```

tag指令： 标签，稳定上线版本.我们常常在代码封板时,使用git创建一个tag ,这样一个不可修改的历史代码版本就像被我们封存起来一样,不论是运维发布拉取,或者以后的代码版本管理,都是十分方便的

```
git tag                         //查看本地tag
git tag -d <tagName>            //删除tag
git tag <newTagName>		    //新建tag
git tag -a <tagName> <commitId> //以历史的某个提交id创建tag
git push origin <newTagName>    //推送到远程仓库
```

## 关于分支的维护
新分支维护：1.基于现在新的develop分支拉出新的分支。2.更新，提交更替版本。3.完成功能开发后，如有公共修改部分则创建common分支。4.切回原分支，reset回拉出时版本，checkout [basebranch]-- 公共配置文件文件，提交所有更新。5.rebase origin develop，解决冲突提交。6.push。
已有分支维护：1.如存在common分支，checkout common -- commonpath，还原公共修改。2.更新，开发，迭代版本。3.有额外的公共部分可切换至common，使用common checkout更新提交。4.继续如上4步骤及后续。
# SSH

[其他](https://hujinyang.blog.csdn.net/article/details/116600163)